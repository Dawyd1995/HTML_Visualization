<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Vertical City V4</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* HUD UI */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 5, 10, 0.85);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 4px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            z-index: 10;
        }
        .hud-row { margin-bottom: 8px; display: flex; justify-content: space-between; min-width: 220px; font-size: 14px; }
        .hud-label { font-weight: bold; margin-right: 15px; opacity: 0.7; }
        .hud-value { font-weight: bold; text-align: right; }
        .status-pill {
            display: inline-block; padding: 2px 6px; border-radius: 4px; 
            font-size: 10px; background: #111; border: 1px solid #555; margin-left: 5px;
        }
        
        /* Scanline Overlay */
        .scan-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 2px, rgba(0,255,255,0.03) 3px, rgba(0,0,0,0) 4px);
            z-index: 5;
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; display: flex; justify-content: center; align-items: center;
            color: #0ff; z-index: 999; flex-direction: column;
        }
    </style>
</head>
<body>

<div id="loader">
    <h1 style="text-shadow: 0 0 20px #0ff;">CONSTRUCTING MEGACITY...</h1>
    <div style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">Building Vertical Layers</div>
</div>

<div class="scan-overlay"></div>

<div id="hud">
    <div style="border-bottom: 1px solid #0ff; margin-bottom: 10px; padding-bottom: 5px; font-weight:900;">NEURAL LINK V4.0</div>
    <div class="hud-row"><span class="hud-label">PROGRESS</span><span id="hud-progress" class="hud-value">0%</span></div>
    <div class="hud-row"><span class="hud-label">LEVEL</span><span id="hud-level" class="hud-value">GROUND <span class="status-pill" id="level-pill">STABLE</span></span></div>
    <div class="hud-row"><span class="hud-label">VALUE</span><span id="hud-price" class="hud-value">0.00</span></div>
    <div class="hud-row"><span class="hud-label">FPS</span><span id="hud-fps" class="hud-value">60</span></div>
</div>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // --- CONFIG ---
    const CONFIG = {
        duration: 90, // Sehr lang für epische Fahrt
        autoFly: true,
        
        // City Generierung
        cityDensity: 0.8,    // 0..1
        buildingScale: 1.2,  // Multiplikator
        
        // Vertical Logic
        jumpThreshold: 25,   // Wie viel Price-Change für einen "Wall Climb" nötig ist
        levelHeight: 40,     // Höhe eines Stockwerks/Levels

        // Graphics
        bloomStrength: 1.8,
        bloomRadius: 0.6,
        bloomThreshold: 0.15,
        fogDensity: 0.015,
        
        cameraMode: 'FOLLOW_STABLE',
        palette: 'CYAN_MAGENTA'
    };

    const STATE = {
        progress: 0,
        time: 0,
        fps: 60,
        currentLevel: 0, // Logisches Level (0 = Ground, 1 = Sky, -1 = Under)
        camForward: new THREE.Vector3(0, 0, 1),
        camPosSmoothed: new THREE.Vector3(0, 5, 0),
        camLookSmoothed: new THREE.Vector3(0, 0, 10),
        currentLookAhead: 0,
        currentDist: 0,
        currentHeight: 0
    };

    // --- HELPER: TEXTURES ---
    function createBuildingTexture(p1, p2) {
        const c = document.createElement('canvas'); c.width=64; c.height=128;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#020202'; ctx.fillRect(0,0,64,128); // Dark base
        
        const cols = [p1, p2, '#ffffff', '#aaaaaa'];
        for(let i=0; i<40; i++) {
            ctx.fillStyle = cols[Math.floor(Math.random()*cols.length)];
            const x = Math.floor(Math.random()*4)*16 + 2;
            const y = Math.floor(Math.random()*8)*16 + 2;
            const w = 10; 
            const h = Math.random()>0.7 ? 26 : 8;
            if(Math.random()>0.5) ctx.fillRect(x,y,w,h);
        }
        const tex = new THREE.CanvasTexture(c);
        tex.magFilter = THREE.NearestFilter;
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
    }

    function createFogSprite() {
        const c = document.createElement('canvas'); c.width=128; c.height=128;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(64,64,0,64,64,64);
        g.addColorStop(0, 'rgba(255,255,255,0.4)');
        g.addColorStop(0.5, 'rgba(255,255,255,0.1)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
        return new THREE.CanvasTexture(c);
    }

    // --- PALETTEN ---
    const PALETTES = {
        CYAN_MAGENTA: { prim: '#00ffff', sec: '#ff00ff', sky: '#000810', fog: '#000810', grid: '#002233' },
        AMBER_TEAL:   { prim: '#ffae00', sec: '#008080', sky: '#050300', fog: '#050300', grid: '#332200' },
        NEON_GREEN:   { prim: '#39ff14', sec: '#8000ff', sky: '#020005', fog: '#020005', grid: '#113311' },
        SYNTHWAVE:    { prim: '#ff71ce', sec: '#01cdfe', sky: '#120012', fog: '#120012', grid: '#330033' },
        CRIMSON_DARK: { prim: '#ff0033', sec: '#aaaaaa', sky: '#080000', fog: '#080000', grid: '#330000' }
    };

    // --- INIT ---
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, CONFIG.fogDensity);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    
    // Post Processing
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    const composer = new EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(bloomPass);

    // --- DATA & WORLD GENERATION ---
    
    // Global Arrays
    let curve;
    let points = [];
    let buildingsPos = []; // { pos, scale, type }
    let verticalWalls = []; // { pos, height, width, rotation }
    let undergroundZones = []; // { u_start, u_end }

    function generateWorld() {
        points = [];
        buildingsPos = [];
        verticalWalls = [];
        undergroundZones = [];

        // 1. PATH GENERATION (The "Market" Simulation)
        let cx = 0, cz = 0;
        let cy = 0; // Current Height Level
        let price = 100;
        
        // Initial point
        points.push(new THREE.Vector3(0,0,0));

        const segmentCount = 200; // Anzahl logischer Schritte
        const stepSize = 8;       // Distanz pro Schritt in Z (ungefähr)

        for(let i=1; i<segmentCount; i++) {
            // Trend simulieren
            let delta = (Math.random()-0.48) * 15; // Leichter Aufwärtstrend
            // Manchmal extreme Ausbrüche
            if(Math.random() > 0.95) delta *= 4;

            let nextPrice = price + delta;
            
            // Wall Climb Logic
            // Wenn Preisunterschied zum Start des Levels zu groß wird -> Level Change
            const levelDiff = nextPrice - price;
            
            let isVerticalJump = false;
            let jumpHeight = 0;

            // Check Jump Up
            if(delta > CONFIG.jumpThreshold) {
                isVerticalJump = true;
                jumpHeight = CONFIG.levelHeight; 
            } 
            // Check Dive Down
            else if(delta < -CONFIG.jumpThreshold) {
                isVerticalJump = true;
                jumpHeight = -CONFIG.levelHeight;
            }

            // Move forward (X/Z)
            // Curvy path
            const angle = Math.sin(i * 0.1) * 0.5 + (Math.random()-0.5)*0.5;
            const dx = Math.sin(angle) * stepSize;
            const dz = Math.cos(angle) * stepSize;
            
            cx += dx;
            cz += dz;

            if(isVerticalJump) {
                // Füge "Wall" Points ein
                // 1. Punkt an der Basis der Wand
                const baseP = new THREE.Vector3(cx, cy, cz);
                points.push(baseP);

                // Update Level
                cy += jumpHeight;

                // 2. Punkt am Top der Wand (fast gleiche X/Z, nur minimal offset damit Tangente stimmt)
                const topP = new THREE.Vector3(cx + dx*0.1, cy, cz + dz*0.1);
                points.push(topP);

                // Wall Metadata speichern (für Building Generator)
                verticalWalls.push({
                    pos: baseP.clone().lerp(topP, 0.5), // Mitte der Wand
                    height: Math.abs(jumpHeight),
                    isUp: jumpHeight > 0,
                    lookAt: new THREE.Vector3(cx+dx, cy, cz+dz) // Wand zeigt zur Bewegung
                });

            } else {
                // Normales Segment
                // Wir addieren etwas Noise auf Y (Amplitude), aber bleiben auf Level-Höhe
                const localNoise = (Math.random()-0.5) * 2.0; 
                points.push(new THREE.Vector3(cx, cy + localNoise, cz));
            }

            price = nextPrice;
            
            // Detect Underground
            if(cy < -10) {
                // Wir sind tief unten
                // Speichere u-range später oder markiere Punkte
            }
        }

        // Curve erstellen
        curve = new THREE.CatmullRomCurve3(points);
        curve.tension = 0.1; // Sharper corners for vertical jumps
    }

    // Init Data
    generateWorld();

    // --- MESH GENERATION ---
    
    // 1. ROUTE
    const tubeGeo = new THREE.TubeGeometry(curve, 3000, 0.4, 8, false);
    tubeGeo.setDrawRange(0,0);
    const matRoute = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Wird getönt
    const meshRoute = new THREE.Mesh(tubeGeo, matRoute);
    scene.add(meshRoute);

    // 2. BUILDINGS (Instanced)
    const MAX_BUILDINGS = 4000;
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    
    let texBuild = createBuildingTexture('#00ffff', '#ff00ff');
    const matBuild = new THREE.MeshStandardMaterial({
        color: 0x111111, map: texBuild, emissiveMap: texBuild, 
        emissive: 0xffffff, emissiveIntensity: 1.2, roughness: 0.1, metalness: 0.8
    });
    const iMesh = new THREE.InstancedMesh(boxGeo, matBuild, MAX_BUILDINGS);
    scene.add(iMesh);

    // 3. VERTICAL MEGASTRUCTURES (Wände an den Sprüngen)
    const wallGeo = new THREE.BoxGeometry(1,1,1);
    const matWall = new THREE.MeshStandardMaterial({
        color: 0x050505, roughness: 0.2, metalness: 0.9,
        emissive: 0x00ffff, emissiveIntensity: 0.5,
        wireframe: false
    });
    // Wir nutzen normale Meshes für die wenigen Megastructures, einfacher zu handeln
    const wallGroup = new THREE.Group();
    scene.add(wallGroup);

    // 4. FOG SPRITES (Volumetric Clouds)
    const fogGroup = new THREE.Group();
    const fogTex = createFogSprite();
    const fogMat = new THREE.SpriteMaterial({ map: fogTex, color: 0x00ffff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending });
    const fogSprites = [];
    for(let i=0; i<100; i++) {
        const s = new THREE.Sprite(fogMat);
        s.scale.set(40,40,1);
        fogGroup.add(s);
        fogSprites.push({ sprite: s, offset: Math.random()*1000, speed: (Math.random()-0.5)*2 });
    }
    scene.add(fogGroup);

    // --- PLACEMENT LOGIC (Dynamic) ---
    function placeCity() {
        // Reset Instance Mesh
        iMesh.count = 0;
        let idx = 0;

        const dummy = new THREE.Object3D();
        const curvePoints = curve.getSpacedPoints(2000); // Sampling

        for(let i=0; i<curvePoints.length; i++) {
            // Density Check
            if(Math.random() > CONFIG.cityDensity) continue;
            if(idx >= MAX_BUILDINGS) break;

            const pt = curvePoints[i];
            const u = i / curvePoints.length;
            const tan = curve.getTangentAt(u);

            // Skip wenn wir in einem vertikalen Segment sind (erkennbar an starkem Y-Anstieg im Tangentenvektor)
            if(Math.abs(tan.y) > 0.5) continue; 

            // Offset zur Seite
            const norm = new THREE.Vector3(0,1,0).cross(tan).normalize();
            const side = Math.random() > 0.5 ? 1 : -1;
            const dist = 6 + Math.random() * 20;

            dummy.position.copy(pt).add(norm.multiplyScalar(dist * side));
            // Boden-Snap: Das Gebäude soll auf dem aktuellen Level stehen (pt.y)
            // Aber wir runden pt.y auf das nächste Level Grid, falls gewünscht. Hier nehmen wir Curve Height.
            dummy.position.y = pt.y; 

            // Rotation Y only
            dummy.lookAt(pt.x, dummy.position.y, pt.z);
            
            // Size
            const h = (5 + Math.random() * 30) * CONFIG.buildingScale;
            const w = (3 + Math.random() * 5) * CONFIG.buildingScale;
            const d = (3 + Math.random() * 5) * CONFIG.buildingScale;

            dummy.scale.set(w, h, d);
            dummy.position.y += h/2; // Pivot correction
            
            dummy.updateMatrix();
            iMesh.setMatrixAt(idx, dummy.matrix);
            idx++;
        }
        iMesh.count = idx;
        iMesh.instanceMatrix.needsUpdate = true;

        // Place Megastructures (Walls)
        // Clear old
        while(wallGroup.children.length > 0) wallGroup.remove(wallGroup.children[0]);
        
        verticalWalls.forEach(w => {
            const wall = new THREE.Mesh(wallGeo, matWall);
            wall.position.copy(w.pos);
            wall.scale.set(15, w.height, 15); // Massiver Turm
            
            // Ausrichtung
            wall.lookAt(w.lookAt);
            
            // Texturierung oder Details hinzufügen?
            // Wir fügen einfache Lichtstreifen hinzu (Scale trick)
            const strip = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1, 1.1), new THREE.MeshBasicMaterial({color: 0xffffff}));
            strip.scale.set(1, w.height, 0.2);
            wall.add(strip);
            
            wallGroup.add(wall);
        });

        // Place Fog Sprites along curve
        fogSprites.forEach((f, i) => {
            const u = Math.random();
            const pt = curve.getPointAt(u);
            f.sprite.position.copy(pt).add(new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*30, (Math.random()-0.5)*100));
        });
    }

    // Initial Place
    placeCity();


    // --- ASSETS (Props) ---
    // Floor Grid (Infinity Illusion)
    const gridHelper = new THREE.GridHelper(4000, 400, 0x111111, 0x050505);
    gridHelper.position.y = -2; // Slightly below lowest point
    scene.add(gridHelper);

    // Head Marker
    const headGroup = new THREE.Group();
    const headGeo = new THREE.ConeGeometry(0.5, 1.5, 4); headGeo.rotateX(Math.PI/2);
    const headMesh = new THREE.Mesh(headGeo, new THREE.MeshBasicMaterial({ wireframe: true, color: 0xffffff }));
    const headLight = new THREE.PointLight(0xffffff, 2, 30);
    headGroup.add(headMesh); headGroup.add(headLight);
    scene.add(headGroup);

    // --- GUI & LOGIC ---
    function updateWorldParams() {
        placeCity();
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        scene.fog.density = CONFIG.fogDensity;
    }

    function applyPalette(key) {
        const p = PALETTES[key];
        // Colors
        matRoute.color.set(p.prim);
        matWall.emissive.set(p.prim);
        headLight.color.set(p.prim);
        fogMat.color.set(p.sec);
        
        // Background & Fog
        scene.background = new THREE.Color(p.sky);
        scene.fog.color.set(p.fog);
        
        // Texture Regen
        const newTex = createBuildingTexture(p.prim, p.sec);
        matBuild.map = newTex; matBuild.emissiveMap = newTex; matBuild.needsUpdate = true;
        
        // UI Colors
        document.getElementById('hud').style.borderColor = p.prim;
        document.querySelectorAll('.hud-value').forEach(e => e.style.color = p.prim);
    }

    const gui = new GUI({ title: 'CYBER CONTROL V4' });
    const fGen = gui.addFolder('Generation');
    fGen.add(CONFIG, 'cityDensity', 0, 1).onChange(placeCity);
    fGen.add(CONFIG, 'buildingScale', 0.5, 3).onChange(placeCity);
    fGen.add(CONFIG, 'jumpThreshold', 10, 50).name('Wall Threshold').onFinishChange(generateWorld); // Rebuild world needed
    
    const fVis = gui.addFolder('Visuals');
    fVis.add(CONFIG, 'bloomStrength', 0, 3).onChange(updateWorldParams);
    fVis.add(CONFIG, 'bloomRadius', 0, 1).onChange(updateWorldParams);
    fVis.add(CONFIG, 'fogDensity', 0, 0.05).onChange(updateWorldParams);
    fVis.add(CONFIG, 'palette', Object.keys(PALETTES)).onChange(applyPalette);
    
    gui.add(CONFIG, 'cameraMode', ['FOLLOW_STABLE', 'FOLLOW_SWAY', 'DRONE_ORBIT', 'REAR_CHASE_LOW']);
    gui.add(CONFIG, 'duration', 30, 180).name('Loop Time');

    applyPalette('CYAN_MAGENTA');
    document.getElementById('loader').style.display = 'none';

    // --- ANIMATION ---
    const clock = new THREE.Clock();
    const _headPos = new THREE.Vector3();
    const _backPos = new THREE.Vector3();
    const _forward = new THREE.Vector3();
    const _up = new THREE.Vector3(0,1,0);

    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        STATE.time += dt;

        // Progress
        if(CONFIG.autoFly) {
            STATE.progress += dt / CONFIG.duration;
            if(STATE.progress > 1) STATE.progress = 0;
        }
        const u = STATE.progress;

        // Route Visibility
        // Tube Geometry: ca 3000 segments * 8 radial * 6 indices
        const totalIndices = 3000 * 8 * 6;
        const drawCount = Math.floor(u * totalIndices);
        // Align to segment size (48 indices per segment)
        tubeGeo.setDrawRange(0, Math.floor(drawCount / 48) * 48);

        // Head Position
        curve.getPointAt(u, _headPos);
        const tan = curve.getTangentAt(u);
        headGroup.position.copy(_headPos);
        
        // Head Orientation (Achte auf Vertikale Sprünge)
        // Bei senkrechtem Flug (tan.y ~ 1 oder -1) müssen wir Quaternion aufpassen
        if(Math.abs(tan.y) > 0.9) {
            // Wir klettern
            headGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), tan);
        } else {
            headGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), tan);
        }

        // --- CAMERA LOGIC ---
        // Back-Vector Berechnung für stabile Ausrichtung
        const lookBack = 0.005;
        if(u < lookBack) _forward.copy(curve.getTangentAt(0));
        else {
            curve.getPointAt(u - lookBack, _backPos);
            _forward.subVectors(_headPos, _backPos).normalize();
        }
        
        // Stabilisierung
        if(_forward.lengthSq() > 0.5) { // Nur wenn bewegung da ist
             STATE.camForward.lerp(_forward, dt * 2.0);
        }

        // Camera Modes
        let tDist=8, tHeight=4, tLook=6;
        let swayX=0, swayY=0;

        // Automatische Anpassung bei Wall Climb
        // Wenn wir steil nach oben/unten fliegen, Abstand vergrößern für Übersicht
        if(Math.abs(_forward.y) > 0.5) {
            tDist = 15; 
            tHeight = 0; // Hinter dem Head bleiben, nicht darüber
        }

        if(CONFIG.cameraMode === 'FOLLOW_STABLE') { /* defaults */ }
        else if(CONFIG.cameraMode === 'DRONE_ORBIT') {
            tDist = 15; tLook = 0;
            swayX = Math.sin(STATE.time * 0.5) * 10;
            tHeight = 8 + Math.cos(STATE.time * 0.3) * 4;
        }

        STATE.currentDist += (tDist - STATE.currentDist) * dt * 2;
        STATE.currentHeight += (tHeight - STATE.currentHeight) * dt * 2;

        const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), STATE.camForward).normalize();
        
        // Target Calc
        const targetPos = _headPos.clone()
            .sub(STATE.camForward.clone().multiplyScalar(STATE.currentDist))
            .add(new THREE.Vector3(0, STATE.currentHeight, 0))
            .add(right.multiplyScalar(swayX));

        STATE.camPosSmoothed.lerp(targetPos, dt * 3.0);
        camera.position.copy(STATE.camPosSmoothed);
        
        const targetLook = _headPos.clone().add(STATE.camForward.clone().multiplyScalar(tLook));
        STATE.camLookSmoothed.lerp(targetLook, dt * 4.0);
        camera.lookAt(STATE.camLookSmoothed);

        // --- ATMOSPHERE UPDATE ---
        // Wenn wir unter Y=0 sind (Underground) -> Rotes Licht / Dunkler Nebel
        if(_headPos.y < -5) {
            // Smooth transition zu Underground Theme
            const darkColor = new THREE.Color(0x110000);
            scene.fog.color.lerp(darkColor, dt);
            scene.background.lerp(new THREE.Color(0x000000), dt);
            document.getElementById('level-pill').innerText = "UNDERGROUND";
            document.getElementById('level-pill').style.color = "red";
            document.getElementById('level-pill').style.borderColor = "red";
        } else {
            // Zurück zum Standard (Palette Sky)
            const p = PALETTES[CONFIG.palette];
            scene.fog.color.lerp(new THREE.Color(p.fog), dt);
            scene.background.lerp(new THREE.Color(p.sky), dt);
            
            if(_headPos.y > 20) {
                 document.getElementById('level-pill').innerText = "SKY LEVEL";
                 document.getElementById('level-pill').style.color = "#0ff";
                 document.getElementById('level-pill').style.borderColor = "#0ff";
            } else {
                 document.getElementById('level-pill').innerText = "GROUND";
                 document.getElementById('level-pill').style.color = "#aaa";
                 document.getElementById('level-pill').style.borderColor = "#aaa";
            }
        }

        // Fog Sprites Animation
        fogSprites.forEach(f => {
            // Move slowly
            f.sprite.position.x += f.speed * dt;
            // Wrap around camera
            const d = f.sprite.position.distanceTo(camera.position);
            if(d > 200) {
                f.sprite.position.copy(camera.position).add(new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*20, (Math.random()-0.5)*100));
            }
            f.sprite.lookAt(camera.position);
        });

        // HUD Update
        document.getElementById('hud-progress').innerText = Math.floor(u*100) + '%';
        // Preis aus Y berechnen (ungefähr)
        document.getElementById('hud-price').innerText = (100 + _headPos.y).toFixed(2);
        document.getElementById('hud-fps').innerText = Math.round(1/dt);

        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>