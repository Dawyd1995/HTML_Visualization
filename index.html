<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Live Route Visualizer V2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* HUD UI */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        .hud-row { margin-bottom: 5px; display: flex; justify-content: space-between; min-width: 200px; }
        .hud-label { font-weight: bold; margin-right: 15px; opacity: 0.8; }
        .hud-value { font-weight: bold; }
        .scan-line {
            width: 100%; height: 2px; background: #0ff; opacity: 0.5;
            margin-top: 10px;
            animation: scan 2s infinite linear;
        }
        @keyframes scan { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #0ff; z-index: 999; flex-direction: column;
        }
    </style>
</head>
<body>

<div id="loader">
    <h1 style="text-shadow: 0 0 20px #0ff;">SYSTEM REBOOT...</h1>
    <div style="font-size: 0.8em; opacity: 0.7;">Generiere Texturen & Welt</div>
</div>

<div id="hud">
    <div class="hud-row"><span class="hud-label">PROGRESS</span><span id="hud-progress" class="hud-value">0%</span></div>
    <div class="hud-row"><span class="hud-label">INDEX</span><span id="hud-index" class="hud-value">0</span></div>
    <div class="hud-row"><span class="hud-label">VALUE</span><span id="hud-price" class="hud-value">0.00</span></div>
    <div class="hud-row"><span class="hud-label">FPS</span><span id="hud-fps" class="hud-value">60</span></div>
    <div class="scan-line"></div>
</div>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // --- CONFIG ---
    const CONFIG = {
        pointCount: 1500,
        duration: 30,
        autoFly: true,
        verticalAmp: 2.0, // Default höher damit man was sieht
        bloomStrength: 1.2,
        bloomThreshold: 0.1, // Niedriger Threshold damit mehr leuchtet
        bloomRadius: 0.5,
        cameraMode: 'FOLLOW_STABLE',
        palette: 'CYAN_MAGENTA'
    };

    const STATE = {
        progress: 0,
        time: 0,
        fps: 60,
        camForward: new THREE.Vector3(0, 0, 1),
        camPosSmoothed: new THREE.Vector3(0, 5, 0),
        camLookSmoothed: new THREE.Vector3(0, 0, 10),
        currentLookAhead: 0,
        currentDist: 0,
        currentHeight: 0
    };

    // --- HELPER: TEXTURE GENERATION ---
    // Erzeugt Canvas-Texturen für Fenster/Lichter damit die Stadt bunt ist
    function createBuildingTexture(primaryColor, secondaryColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 128; // Low res reicht für Instancing
        const ctx = canvas.getContext('2d');
        
        // Background dark
        ctx.fillStyle = '#050505';
        ctx.fillRect(0,0,64,128);
        
        // Random Windows
        const colorPalette = [primaryColor, secondaryColor, '#ffffff', '#ffff00'];
        
        for(let i=0; i<30; i++) {
            const c = colorPalette[Math.floor(Math.random()*colorPalette.length)];
            ctx.fillStyle = c;
            const x = Math.floor(Math.random()*4) * 16 + 2;
            const y = Math.floor(Math.random()*8) * 16 + 2;
            const w = 10;
            const h = Math.random() > 0.8 ? 28 : 10; // Manche Fenster hoch
            
            if(Math.random() > 0.4) { // Nicht alles vollkleistern
                ctx.globalAlpha = 0.8 + Math.random()*0.2; // Variation in Helligkeit
                ctx.fillRect(x,y,w,h);
            }
        }
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter; // Pixel look
        return tex;
    }

    // Erzeugt eine Noise Map für "Pfützen" auf dem Boden
    function createRoughnessMap() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,512,512);
        
        for(let i=0; i<400; i++) {
            const x = Math.random()*512;
            const y = Math.random()*512;
            const r = Math.random()*30 + 10;
            const grad = ctx.createRadialGradient(x,y,0,x,y,r);
            grad.addColorStop(0, 'rgba(0,0,0,0.8)'); // Glatt (nass)
            grad.addColorStop(1, 'rgba(255,255,255,0)'); // Rau (trocken)
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        }
        
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }

    // --- PALETTEN ---
    const PALETTES = {
        CYAN_MAGENTA: { 
            primary: '#00ffff', secondary: '#ff00ff', sky: 0x000510, fog: 0x000510 
        },
        AMBER_TEAL: { 
            primary: '#ffae00', secondary: '#008080', sky: 0x050300, fog: 0x050300
        },
        NEON_GREEN_PURPLE: { 
            primary: '#39ff14', secondary: '#9d00ff', sky: 0x020005, fog: 0x020005
        },
        RED_BLUE: { 
            primary: '#ff0033', secondary: '#0033ff', sky: 0x050002, fog: 0x050002
        },
        SYNTHWAVE: { 
            primary: '#ff71ce', secondary: '#01cdfe', sky: 0x180c18, fog: 0x180c18
        }
    };

    // --- SCENE SETUP ---
    const container = document.getElementById('canvas-container');
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Performance Balance
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.012);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Composer
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    // Settings init
    bloomPass.threshold = CONFIG.bloomThreshold;
    bloomPass.strength = CONFIG.bloomStrength;
    bloomPass.radius = CONFIG.bloomRadius;

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- DATA ---
    function generateData(count) {
        const data = [];
        let price = 50;
        
        for (let i = 0; i < count; i++) {
            // Sinus + Noise für klarere Amplitude
            const t = i * 0.1;
            const sineWave = Math.sin(t * 0.5) * 10; // Langsame große Welle
            const fastWave = Math.cos(t * 2.0) * 3;  // Schnelle kleine Welle
            const noise = (Math.random() - 0.5) * 4;
            
            price = 50 + sineWave + fastWave + noise;
            
            // X/Z Curve
            const x = Math.sin(i * 0.03) * 60 + Math.cos(i * 0.01) * 20;
            const z = i * 4;

            data.push({ x, z, rawPrice: price });
        }
        return data;
    }

    const rawData = generateData(CONFIG.pointCount);
    // Normalize
    const prices = rawData.map(d => d.rawPrice);
    const minP = Math.min(...prices);
    const maxP = Math.max(...prices);
    
    const points = rawData.map(d => ({
        vec: new THREE.Vector3(d.x, 0, d.z),
        normPrice: (d.rawPrice - minP) / (maxP - minP),
        raw: d.rawPrice
    }));

    // --- CURVE ---
    const curve = new THREE.CatmullRomCurve3(points.map(p => p.vec));
    const tubeGeo = new THREE.TubeGeometry(curve, 1500, 0.3, 8, false); // Dickerer Trail
    tubeGeo.setDrawRange(0, 0);

    const matRoute = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Wird von Palette überschrieben
    const meshRoute = new THREE.Mesh(tubeGeo, matRoute);
    scene.add(meshRoute);

    function updateCurveHeight() {
        const positions = curve.points;
        for(let i=0; i<positions.length; i++) {
            // Apply Amplitude to Y
            positions[i].y = 0.5 + points[i].normPrice * CONFIG.verticalAmp * 10; // *10 für dramatischen Effekt
        }
        // Dirty update
        curve.updateArcLengths();
        
        // Geometrie neu bauen leider nötig bei Kurven-Update für Tube
        // Performance OK da nur bei Slider change
        const newGeo = new THREE.TubeGeometry(curve, 1500, 0.3, 8, false);
        tubeGeo.copy(newGeo);
        // DrawRange reset verhindern wir im Loop
    }
    updateCurveHeight();

    // --- CITY ASSETS ---
    const cityGroup = new THREE.Group();
    scene.add(cityGroup);

    // Textures
    let buildingTex = createBuildingTexture('#00ffff', '#ff00ff');

    // Materials
    const matBuilding = new THREE.MeshStandardMaterial({
        color: 0x222222,
        map: buildingTex,
        emissiveMap: buildingTex,
        emissive: 0xffffff,
        emissiveIntensity: 1.5, // Bright!
        roughness: 0.2,
        metalness: 0.8
    });

    const matRoof = new THREE.MeshBasicMaterial({ color: 0x111111 });

    // Instanced Mesh Construction
    const count = 700;
    const iMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(1,1,1), matBuilding, count);
    const iMeshRoof = new THREE.InstancedMesh(new THREE.BoxGeometry(1,0.1,1), matRoof, count);
    cityGroup.add(iMesh);
    cityGroup.add(iMeshRoof);

    const dummy = new THREE.Object3D();
    const curvePoints = curve.getSpacedPoints(count);

    for(let i=0; i<count; i++) {
        const u = i/count;
        const pt = curvePoints[i];
        const tan = curve.getTangentAt(u);
        const norm = new THREE.Vector3(0,1,0).cross(tan).normalize();
        
        const side = Math.random() > 0.5 ? 1 : -1;
        const dist = 5 + Math.random() * 15;
        
        // Position
        dummy.position.copy(pt).add(norm.clone().multiplyScalar(dist * side));
        dummy.position.y = 0; // Ground
        
        // Rotation
        dummy.lookAt(pt);
        
        // Scale based on Data + Random
        const dataIdx = Math.floor(u * (points.length-1));
        const val = points[dataIdx].normPrice;
        const h = 4 + val * 20 + Math.random() * 10;
        const w = 2 + Math.random() * 3;
        const d = 2 + Math.random() * 3;
        
        dummy.scale.set(w, h, d);
        dummy.position.y = h/2; // Center Pivot fix
        dummy.updateMatrix();
        iMesh.setMatrixAt(i, dummy.matrix);
        
        // Roof top
        dummy.scale.set(w*0.9, 1, d*0.9);
        dummy.position.y = h + 0.05;
        dummy.updateMatrix();
        iMeshRoof.setMatrixAt(i, dummy.matrix);
    }

    // --- CRAZY OBJECTS (Tunnels, Rings, Sculptures) ---
    const crazyGroup = new THREE.Group();
    scene.add(crazyGroup);
    
    // Mat for crazy objects
    const matCrazy = new THREE.MeshStandardMaterial({ 
        color: 0x444444, roughness: 0.1, metalness: 0.9, 
        emissive: 0xff00ff, emissiveIntensity: 0.5, wireframe: false 
    });

    // 1. Torus Knots als Skulpturen
    const knotGeo = new THREE.TorusKnotGeometry(2, 0.4, 64, 8);
    for(let i=0; i<5; i++) {
        const u = 0.15 + i * 0.2;
        const pt = curve.getPointAt(u);
        const mesh = new THREE.Mesh(knotGeo, matCrazy);
        mesh.position.copy(pt);
        mesh.position.y += 10;
        mesh.scale.setScalar(2 + Math.random());
        crazyGroup.add(mesh);
    }

    // 2. Tunnel / Gates
    const gateGeo = new THREE.TorusGeometry(6, 0.5, 8, 20, Math.PI * 2); // Ring
    for(let i=0; i<8; i++) {
        const u = 0.1 + i * 0.12;
        const pt = curve.getPointAt(u);
        const tan = curve.getTangentAt(u);
        
        const gate = new THREE.Mesh(gateGeo, matCrazy);
        gate.position.copy(pt);
        gate.position.y += 2; // Curve center
        gate.lookAt(pt.clone().add(tan));
        crazyGroup.add(gate);
    }

    // --- MOON ---
    const moonGeo = new THREE.SphereGeometry(40, 32, 32);
    const moonMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        map: createRoughnessMap() // Missbrauche Roughness Map als Mond Texture :D
    }); 
    const moon = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moon);

    // --- FLOOR ---
    const floorTex = createRoughnessMap();
    floorTex.repeat.set(50,50);
    const matFloor = new THREE.MeshStandardMaterial({
        color: 0x050505,
        roughnessMap: floorTex,
        roughness: 0.1, // Sehr glatt wo schwarz (nass)
        metalness: 0.9,
    });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), matFloor);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // --- TAXIS ---
    const taxiGroup = new THREE.Group();
    scene.add(taxiGroup);
    const taxis = [];
    const taxiGeo = new THREE.BoxGeometry(0.8, 0.2, 1.2);
    const taxiMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    
    for(let i=0; i<15; i++) {
        const mesh = new THREE.Mesh(taxiGeo, taxiMat);
        // Add random engine lights
        const light = new THREE.PointLight(0xff0000, 1, 5);
        light.position.set(0,0,0.6);
        mesh.add(light);
        
        taxiGroup.add(mesh);
        taxis.push({
            mesh,
            u: Math.random(),
            speed: 0.03 + Math.random() * 0.05,
            offset: new THREE.Vector3((Math.random()-0.5)*10, 2+Math.random()*8, 0)
        });
    }

    // --- HEAD ---
    const headMesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.5, 4), new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true}));
    headMesh.rotateX(Math.PI/2);
    const headLight = new THREE.PointLight(0xffffff, 3, 20);
    const headGroup = new THREE.Group();
    headGroup.add(headMesh);
    headGroup.add(headLight);
    scene.add(headGroup);


    // --- LOGIC ---
    function applyPalette(key) {
        const p = PALETTES[key];
        if(!p) return;
        
        // Colors Update
        const cPrim = new THREE.Color(p.primary);
        const cSec = new THREE.Color(p.secondary);
        
        matRoute.color.set(cPrim);
        moonMat.color.set(cSec).lerp(new THREE.Color(0xffffff), 0.5);
        headLight.color.set(cPrim);
        matCrazy.emissive.set(cSec);
        
        scene.fog.color.setHex(p.fog);
        renderer.setClearColor(p.sky);
        
        // New texture generation with correct colors
        const newTex = createBuildingTexture(p.primary, p.secondary);
        matBuilding.map = newTex;
        matBuilding.emissiveMap = newTex;
        matBuilding.needsUpdate = true;
        
        // UI
        document.getElementById('hud').style.borderColor = p.primary;
        document.getElementById('hud').style.color = p.primary;
        document.querySelectorAll('.scan-line').forEach(e => e.style.background = p.primary);
    }


    // --- GUI ---
    const gui = new GUI({ title: 'CYBER CONTROL V2' });
    gui.add(CONFIG, 'verticalAmp', 0, 5).name('Vert Amplitude').onChange(updateCurveHeight);
    gui.add(CONFIG, 'bloomStrength', 0, 3).name('Bloom Glow').onChange(v => bloomPass.strength = v);
    gui.add(CONFIG, 'bloomRadius', 0, 1).name('Bloom Radius').onChange(v => bloomPass.radius = v);
    gui.add(CONFIG, 'bloomThreshold', 0, 1).name('Bloom Thresh').onChange(v => bloomPass.threshold = v);
    gui.add(CONFIG, 'cameraMode', ['FOLLOW_STABLE', 'FOLLOW_SWAY', 'DRONE_ORBIT', 'REAR_CHASE_LOW']).name('Cam Mode');
    gui.add(CONFIG, 'palette', Object.keys(PALETTES)).name('Palette').onChange(applyPalette);

    applyPalette('CYAN_MAGENTA');
    document.getElementById('loader').style.display = 'none';

    // --- ANIM LOOP ---
    const clock = new THREE.Clock();
    
    const _headPos = new THREE.Vector3();
    const _backPos = new THREE.Vector3();
    const _forward = new THREE.Vector3();
    const _up = new THREE.Vector3(0,1,0);
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        STATE.time += dt;
        
        if(CONFIG.autoFly) {
            STATE.progress += dt / CONFIG.duration;
            if(STATE.progress > 1) STATE.progress = 0;
        }
        const u = STATE.progress;

        // Route DrawRange
        const total = 1500 * 8 * 6;
        const visible = Math.floor(u * total);
        const safe = Math.floor(visible / 48) * 48; // safe segment align
        tubeGeo.setDrawRange(0, safe);

        // Head
        curve.getPointAt(u, _headPos);
        const tan = curve.getTangentAt(u);
        headGroup.position.copy(_headPos);
        headGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), tan);

        // Camera Logic (Reuse stable logic)
        const lookBackDelta = 0.02;
        if (u < 0.02) _forward.copy(curve.getTangentAt(0));
        else {
            curve.getPointAt(u - lookBackDelta, _backPos);
            _forward.subVectors(_headPos, _backPos).normalize();
        }
        
        // Anti-Flip
        if(_forward.dot(STATE.camForward) > 0 || u < 0.05) {
             STATE.camForward.lerp(_forward, dt * 3.0);
        }

        // Cam Modes
        let tDist = 6, tHeight = 3, tLook = 5;
        let swayX = 0, swayY = 0;
        
        if(CONFIG.cameraMode === 'FOLLOW_STABLE') { tDist=8; tHeight=4; tLook=10; }
        if(CONFIG.cameraMode === 'FOLLOW_SWAY') { 
            tDist=7; tHeight=3; tLook=8; 
            swayX = Math.sin(STATE.time)*1.5; swayY = Math.cos(STATE.time*0.7)*0.5; 
        }
        if(CONFIG.cameraMode === 'DRONE_ORBIT') { 
            tDist=15; tHeight=8; tLook=2; 
            swayX = Math.sin(STATE.time*0.3)*10; 
        }
        if(CONFIG.cameraMode === 'REAR_CHASE_LOW') { tDist=4; tHeight=1.5; tLook=15; }

        STATE.currentDist += (tDist - STATE.currentDist) * dt * 2;
        STATE.currentHeight += (tHeight - STATE.currentHeight) * dt * 2;
        
        const right = new THREE.Vector3().crossVectors(_up, STATE.camForward).normalize();
        const targetPos = _headPos.clone()
            .sub(STATE.camForward.clone().multiplyScalar(STATE.currentDist))
            .add(_up.clone().multiplyScalar(STATE.currentHeight))
            .add(right.multiplyScalar(swayX)).add(_up.clone().multiplyScalar(swayY));
            
        STATE.camPosSmoothed.lerp(targetPos, dt * 4); // schnellerer follow
        camera.position.copy(STATE.camPosSmoothed);
        
        const targetLook = _headPos.clone().add(STATE.camForward.clone().multiplyScalar(tLook));
        STATE.camLookSmoothed.lerp(targetLook, dt * 4);
        camera.lookAt(STATE.camLookSmoothed);

        // Intro Lift
        if(STATE.time < 2) camera.position.y += (2-STATE.time)*5;

        // Moon Position (Parallax fake: immer hinten oben rechts)
        const moonDist = 400;
        const moonOffset = new THREE.Vector3(100, 150, -300); // Relativ zur Cam
        moonOffset.applyQuaternion(camera.quaternion); // Mitdrehen? Nein, statisch im Sky besser
        // Einfacher: Fixe Position relativ zum Head aber weit weg
        moon.position.copy(_headPos).add(new THREE.Vector3(100, 200, 400));
        moon.lookAt(camera.position); // Billboard effect

        // Taxis
        taxis.forEach(t => {
            t.u += t.speed * dt;
            if(t.u > 1) t.u = 0;
            const pt = curve.getPointAt(t.u);
            const ttan = curve.getTangentAt(t.u);
            const norm = new THREE.Vector3(0,1,0).cross(ttan).normalize();
            
            // Fly along curve but with offset
            const finalPos = pt.clone().add(norm.multiplyScalar(t.offset.x)).add(new THREE.Vector3(0, t.offset.y, 0));
            t.mesh.position.copy(finalPos);
            t.mesh.lookAt(finalPos.clone().add(ttan));
        });

        // Crazy Objects Rotation
        crazyGroup.children.forEach((child, i) => {
            if(child.geometry.type === 'TorusKnotGeometry') {
                child.rotation.x += dt * 0.2;
                child.rotation.y += dt * 0.1;
            }
        });

        // HUD
        const idx = Math.floor(u * (points.length-1));
        document.getElementById('hud-progress').innerText = Math.floor(u*100)+'%';
        document.getElementById('hud-price').innerText = points[idx].raw.toFixed(2);
        document.getElementById('hud-fps').innerText = Math.round(1/dt);

        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>